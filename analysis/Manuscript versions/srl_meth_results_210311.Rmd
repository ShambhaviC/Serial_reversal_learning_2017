---
title: "Serial Reversal Learning in wild nectar-feeding bats"
author: "Shambhavi"
output:
  html_document: default
  pdf_document: default
fig_caption: yes
---
<style>
body {
text-align: justify}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, fig.align = "center")
```

```{r Reading in the packages, include=FALSE, results= 'hide'}
# clearing the environment
rm(list = ls())

# setting the working directory 
setwd("/Users/shambhavi/Google Drive/Experiments & Data/srl_2017_backup_additionalfiles/Reports")

# creating a vector of the required packages 

packages <- c("rmarkdown", "reshape2", "knitr", "kableExtra", "scales", "tidyverse", "ggpubr", "gridExtra",  "Hmisc", "brms", "bayesplot")

# loading the required packages 
sapply(packages, library, character.only = TRUE)
```

# Introduction 

# Methods 

## Study site and subjects
The experiment was done in June and July 2017 at La Selva Biological Field Station, Province Heredia, Costa Rica. Male and female individuals of the species *Glossophaga commissarisi*, were captured from the wild for the experiment. The bats were attracted to a particular location in the forest using sugar-water (see **Reward** below) as bait and then caught in mist-nets. The bats were sexed and the selected individuals were were then taken to flight cages at another location in the rainforest. These were 4 x 6 m cabins with mesh walls, and thus with the same climactic conditions as the surrounding environment. The bats were weighed, radio frequency identification (RFID) tags were placed around their necks as collars (assigned uniquely to each bat) and released into the flight cages so they could fly within them freely. 4 bats at a time were put into a flight cage. These were called 'groups' and all the individuals in a group were of the same sex. 

Before the start of the experiment the procedure was tested with 4 females or 'beta bats' and refinements were made. The data from these individuals were not analysed. Of the bats that participated in the main experiment, most completed it and a few did not. The bats were released back into the forest upon completing the experiment, or as soon as we noticed they were not consuming a sufficient number of calories to maintain a healthy weight. Prior to release the RFID collars were removed, the bats were weighed to ensure they had not lost too much weight (see **Supplementary Information - Table 1** for details). No blinding was done as all the data collection was completely automatized. 14 bats in total (7 males and 7 females) completed the experiment and the data from these animals were analyzed. 
Animal experimental procedures were reviewed and permission for animal experimentation and RFID-tagging was granted by Sistema Nacional de Areas de Conservación (SINAC) at the Ministerio de
Ambiente y Energía (MINAE) Costa Rica.

## Experimental Setup
### Reward
The reward received by the bats during the experiment was also their main source of food. The reward was a 17% by weight solution of sugar dissolved in water (prepared fresh everyDay), hereafter referred to as 'nectar'. The sugar consisted of a 1:1:1 mass-mixture of sucrose, fructose and dextrose. The nectar was thus similar in composition and concentration to the nectar produced by wild chiropterophilous plants (Baker et al., 1998).

### Flower and pump setup
Each flight cage had a square plastic frame in the center (2x2x1.5m). 8 reward-dispensing devices - hereafter referred to as 'flowers' - were fixed in a radial pattern on this frame, two on each side of the square (see Figure 1) with a minimum distance of 40 cm between adjacent flowers. This is known to be a distance discriminable by these bats (**Winter and Stich, 2005**). Each flower had the following parts: 

* An RFID reader mounted on a plastic cylinder around the head of the flower 
* An infra-red light-barrier beam
* An electronic pinch valve through which a PVC tube was placed and fixed to the head of the flower

A single stepper-motor pump was placed in the center of the plastic frame. The pump contained a 25 mL Hamilton glass syringe (Sigma Aldrich) which was connected to the tubing system of the flowers through 5 pinch valves. These pinch valves controlled the flow of liquid from the pump to the system and from a reservoir of liquid to the pump. This reservoir (500 mL thread bottle, Roth, Germany) was filled with fresh nectar every day and connected to the syringe through the valves. The nectar was then pushed by the syringe through the valves into the tubes. 

When an RFID-tagged bat approached a flower, the individual RFID number was read by the reader. If the bat then poked its nose into the flower and broke the light barrier, it triggered the release of a reward. The pinch valve opened and the pump moved the correct number of pre-programmed steps to dispense nectar to the head of the flower. The bat could easily hover in front of the flower and lick this up. Only when both events occured, i.e., the RFID reader detected a bat and the light-barrier was broken, would a reward be triggered.

The flowers and the pump were connected to a Lenovo ThinkPad laptop computer, which ran the experimental programs and the programs used to clean and fill the systems: PhenoSoft Control 16, PhenoSoft GmBH, Berlin, Germany. The raw data were also recorded to this computer as comma-separated values (CSV) files.

```{r, Figure of the setup, fig.cap= "Figure 1: a) Schematic of the cage and flower set-up b) Pump from Cage 1 c) Pump from Cage 2"}

include_graphics("/Users/shambhavi/Google Drive/Experiments & Data/srl_2017_backup_additionalfiles/Reports/allthree.png")

```

## Experimental procedure
Every day at around 10 AM the old nectar was emptied from the system. The system was rinsed and filled with plain water until 3 PM in the afternoon, when it was filled again with fresh nectar. Twice a week the system was filled with 70% ethanol for an hour to guard against fungal growth, then repeatedly rinsed with water. 

```{r Calculating the time taken for the pump to fill up, message = FALSE, warning = FALSE, message = FALSE, echo=FALSE, results='hide'}
# reading in the pre-processed data to demonstrate the pump fill time 

raw_data_preproc <- read.csv2("raw_data_preproc.csv", sep = ";", header = TRUE)

pump_time <- raw_data_preproc %>% 
  arrange(DateTime) %>% 
  group_by(Cage) %>% 
  filter(MsgValue1 == "start pump" | MsgValue1 == "end pump") %>% 
  mutate(interval = as.integer(difftime(lead(DateTime), DateTime, units = "mins"))) %>% 
  select(DateTime, IdLabel, Condition, Cage, MsgValue1, interval) %>% 
  filter(interval < 20) %>% 
  group_by(Cage) %>% 
  summarise(mean_filltime = round(mean(interval), digits = 2),  
            sd_filltime = round(sd(interval), digits = 2))
```

Each bat was uniquely assigned 2 adjacent flowers on the same side of the square frame, out of the array of 8. These flowers were programmed to reward only 1 of the 4 bats in the cage. After the afternoon procedure of filling the system with fresh nectar was completed, 'test' visits were made to the flowers to ensure that they delivered rewards correctly. The program was then left running for the rest of the night for data collection. Thus, the bats could begin visiting the flowers to collect a reward whenever they chose, which was usually around 6 PM in the evening. During the course of the night, when the syringe of the pump had been emptied, the pump re-filled automatically. This process was quite fast, about `r as.numeric(pump_time[1, 2])` minutes (SD = ±`r as.numeric(pump_time[1 ,3])`) in Cage 1 and `r as.numeric(pump_time[2, 2])` minutes (SD = ±`r as.numeric(pump_time[2, 3])`) in Cage 2. Notably, during this time the bats could not get rewards, even if they made proper visits to the correct flowers.

Every day the bats were also given ad-libitum supplemental food:3.5g of hummingbird food (NektarPlus, Nekton) in 100 mL of water and 3.5g of milk powder (Nido 1+, Nestle) in 100 mL of water. They were also given a small bowl of locally-sourced bee pollen. 

## Experimental design
The experiment proceeded through the following stages. 

* Ad-lib reward

On the night the naive bats were captured and placed into the flight cages they received ad-libitum reward from all the flowers all night long. To enable the bats to find the flowers a small cotton pad soaked in dimethyl disulphide (a chemical attractant produced by many bat-pollinated flowers - von Helversen et al., 2000) was placed on the flowers. A small drop of honey was applied to the inside of the flowers to encourage the bats to place their heads inside, break the light-barrier and trigger a nectar reward. The bats nearly always found the flowers and learned to trigger rewards quickly. 

* Flower training

After the bats had learned to trigger rewards, the next stage of training involved assigning the bats uniquely to 2 out of the 8 flowers in the array. This stage was similar to Ad-libitum, except the bats could only trigger a reward at their assigned flowers. 

* Alternation

To ensure that the bats were familiar with both flowers assigned to them they went through one final stage of training: forced alternation between the two assigned flowers all night long. 

* Main Experiment

In this serial reversal learning task the bats had to choose between a flower that gave 40 $\mu$L of nectar (S+) and one that gave no reward at all (S-). The spatial locations of the two flowers served as the cues indicating which flower was the profitable one. After a bat had made 50 visits in total to the two flowers a reversal occurred: the previously rewarding flower became the non-rewarding flower and vice versa. The batch of 50 visits that occurred between two consecutive reversals (when the location of the S+ and S- stayed constant) was termed a 'reversal block', including the first 50 visits of a night when the bats had not experienced any reversal at all that day. This occurred at regular intervals of 50 visits until the bat either stopped making visits or reached a maximum of 300 visits in a night. After the bat had made 300 rewarded visits it could no longer receive a reward that experimental night. There were 5 reversals per night. This stage of the experiment was repeated for 3 nights in a row. Each experimental night was called a 'Day'. The same flower was the first to be rewarding at the start of every Day. Thus, because there were 6 reversals every night, the last flower to be rewarding on a night was non-rewarding at the start of the next night. 

## Statistical analysis 

As some of the animals did not complete all six reversal blocks on some of the Days, the same models described below were fit to just the data from the "complete" animals with nearly identical results. Therefore only the models containing all 14 animals, including the "incomplete" ones are presented here.

To quantify the number of perseverative visits made by the bats the number of visits after the occurrence of a reversal made to the previously rewarding option until the first visit to the newly rewarding option were counted. A Bayesian Markov chain Monte Carlo generalized linear mixed model was fit to these data using the package **brms**, v. 2.14.4 (Bürker, 2017), using a negative-binomial likelihood distribution. Day, reversal block and their interaction were fixed effects and random slopes and intercepts were used to fit regression lines for each individual animal. Weakly informative priors were used: a normal distribution for the slopes and intercepts, a cauchy distribution for the standard deviation. This model had 4 Markov chains with 2000 iterations with a warmup phase of 1000 iterations and a thinning interval of 3. 

The visits to the S+ option were modelled as a binomial distribution, with the a visit to the S+ a 'sucess' and a visit to the S- a 'failure' (1 and 0 respectively). 2 Bayesian Markov chain Monte Carlo generalized linear mixed models were fit to these data as well, both with a binomial likelihood distribution. The first model had day, block, bin and their interactions as fixed effects; random slopes and intercepts were used to fit regression lines for the individuals; 4 Markov chains with 2000 interations and a warmup phase of 1000 interations; and a thinning interval of 3. A second and more complex model was also fit to these data, in order to account for the fact that the first day and the first block of each day were qualitatively different from the others. On the first day the animals had had no prior experience of any reversals, and during the first block of every day they had not experienced any reversals on that day. In addition to day, block and bin as numeric predictor variables, this model also had day and block as factor variables, with the first day and the first block of every day as one level and the other days and other blocks of each day as the other level. This second model too had random slopes and random intercepts for the individuals, 4 Markov chains with 2500 iterations with a warmup phase of 1200 iterations and a thinning interval of 3. The longer chains were necessary for the chains in the more complex model to reach convergence. The two models were then compared using leave-one-out cross-validation, implemented in **brms** using the package **loo**, v.2.3.1 (Vehtari et al., 2016). 

Visual inspection of the trace plots, the number of effective samples, the Gelman-Rubin convergence diagnostic (Rˆ) and the calculation of posterior predictions for the same clusters were all used to assess the fit of the models. In all of the models the Rˆ was equal to 1 for all the chains. 

All statistical analyses were conducted in R, version 4.0.2 (R Core Team, 2020), (**do I put in information about my computer here?**), and all the plots were also created in R, using the **tidyverse** set of packages (v. 1.3.0). 

## Data availability 
All data and analysis code are available online at **github repository**. 

# Results 

## a) Bats showed a very high overall preference for the rewarding option
```{r, Reading in and preparing the data, include = FALSE}
#----------------------------------------
# Preparing data from the main experiment
#----------------------------------------
# loading the prepared CSV file of raw data
raw_data <- read.csv2("raw_data.csv", sep = ";", header = TRUE)

# The following terms are used in the analysis of the data:
# 1. day: a single experimental night during which the data were collected
# 2. block: a group of 50 visits between each reversal where the same flower is rewarding
# 3. bin: a smaller group of visits within a block, the size of which can be set in the code below
# 4. visits: each individual flower visit

# creating a vector of the bats to be excluded from the main analysis
bats_incomp <- c("Bat7", "Bat19")

# creating a vector with the beta bats
bats_beta <- c("Bat1", "Bat2", "Bat3", "Bat4")

# creating a vector of the main experimental days
main_days <- c("Day 1", "Day 2", "Day 3")

# setting binsize and breaks for cutting up the data into block and bin
binsize <- 10
breaks <- seq(0, 3000, binsize)

# placing the visits made by the beta bats in a separate data frame

rev_learning_all_beta <- raw_data %>% 
  filter(IdLabel %in% bats_beta)

# placing the visits made on days 4, 5 and 6 in a separate data frame 

rev_learning_all_lastdays <- raw_data %>% 
  filter(!day %in% main_days)

# preparing a data frame with all the visits, including the proper but unrewarded ones 
rev_learning_all_unrew <- raw_data %>%
  filter(
    # removing the bats that did not complete the experiment
    !IdLabel %in% bats_incomp,
    !IdLabel %in% bats_beta, 
    day %in% main_days, 
    # filtering out the main experimental data
    Condition == "SerialReversalCounter"
  ) %>%
  mutate(
    # marking the difference between the normal visits in a block and the switch points
    MsgValue1 = ifelse(MsgValue1 == "switch", MsgValue1, "block"),  
    # making a column to mark the unrewarded proper visits 
      reinforce1value = replace_na(reinforce1value, 0),
      reinforce1Account = replace_na(reinforce1Account, 0), 
      Unrew = ifelse(reinforce1value != reinforce1Account, 1, 0)
  ) %>%
  rename(Bat = IdLabel) %>%
  arrange(Group, day, Bat, DateTime) %>%
  # grouping the data to count the visits, noting the reversals separately
  group_by(Bat, day) %>%
  mutate(
    # creating a column with the total number of visits made by a bat per day
    count_vis = ifelse(MsgValue1 == "switch", 0, 1), 
    count_vis = cumsum(count_vis)
  ) %>%
  # setting the maximum number of visits a night higher than the programmed max to allow for the 
  # unrewarded visits
  filter(count_vis <= 350) %>%
  ungroup()

# making a separate data frame without any unrewarded visits and preparing it further with block and bin numbers
rev_learning_all <- rev_learning_all_unrew %>% 
  filter(Unrew == 0) %>%
  select(-Unrew) %>%
  # grouping the data to count the visits, noting the reversals separately
  group_by(Bat, day) %>%
  mutate(
    # noting whether the bat made a visit to the more or less rewarding flower
    reward_status = ifelse(reinforce1value > 0, 1, 0),
    # creating a column with the total number of visits made by a bat per day
    count_vis = ifelse(MsgValue1 == "switch", 0, 1), 
    # taking the cumulative sum of the visit counts 
    count_vis = cumsum(count_vis)
  ) %>%
  # setting the maximum number of visits a night
  filter(count_vis <= 300) %>%
  ungroup() %>%
  # creating a column with the reversal block number, marking the reversals
  mutate(block = ifelse(MsgValue1 == "switch", 1, 0)) %>%
  group_by(day, Bat) %>%
  mutate(block = cumsum(block)) %>%
  ungroup() %>% 
  group_by(day, Bat, block) %>%
  # creating a column with the number of visits within each block
  mutate(block_vis = ifelse(MsgValue1 == "switch", 0, 1), 
         block_vis = cumsum(block_vis), 
  # creating a new column for visits in each block to be binned
         bin = "") %>%
  ungroup() %>%
  group_by(day, Bat, block) %>%
  # cutting the visits inside each block into bin of the size set earlier
  mutate(bin = as.numeric(cut(block_vis, breaks, include.lowest = TRUE)))

#---------------------------------------------------
# Calculating the raw proportion of visits to the S+
#---------------------------------------------------
block1 <- rev_learning_all %>% 
  filter(block == 1) %>% 
  summarise(mean_prop = mean(reward_status)*100)

later_bins <- rev_learning_all %>% 
  filter(bin != 1) %>% 
  summarise(mean_prop = mean(reward_status)*100) 

```

Overall, the vast majority of the bats' visits were made to whichever flower was the rewarding one in a particular block (**Figure2**). The general pattern was that, at the start of the each Day, before they had experienced any reversals, the bats made more than `r round(as.numeric(mean(block1$mean_prop), digits = 2))`% (±SD `r round(as.numeric(sd(block1$mean_prop), digits = 2))`) of their visits to the S+; immediately following a reversal, this proportion dropped to 50% and lower. The proportion of visits to the S+ rapidly then climbed back up to approximately `r round(as.numeric(mean(later_bins$mean_prop), digits = 2))`% (±SD `r round(as.numeric(sd(later_bins$mean_prop), digits = 2))`) and more after the first bin of 10 visits following a reversal. 

It is of note that not all the bats completed every reversal block of every Day. Some animals stopped making visits before finishing the maximum of 300 per Day, and some of those also completed the 300 visits on the subsequent Days. However, every single block had data from at least 10 bats, even if they were not always the same bats. (see **Supplementary Figure 1**)

```{r, message = FALSE, warning = FALSE, echo = FALSE, fig.cap = "Figure 2: Average preferences of the bats for the rewarding option. Points are the average preference of the bats in a single bin consisting of 10 visits per bat. The very first block before the bats experienced any reversals at all is marked with white points, the rest with black points. Shaded areas are 95% confidence intervals", fig.width = 9, fig.height = 3}

#--------------
# Overall plot of the bats' preferences over the different days and blocks 
#--------------

# averaging the bats' choice behaviour over day, block and bin
rev_learning_avg <- rev_learning_all %>%
  group_by(day, block) %>%
  mutate(n_bats = n_distinct(Bat)) %>% 
  group_by(day, block, n_bats, bin) %>% 
  # calculating the 95% confidence intervals 
  group_modify(~ mean_cl_boot(.x$reward_status, conf.int = 0.95)) %>%
  ungroup() %>%
  group_by(day) %>%
  mutate(
    day_bin = 1:n(),
    day_bin_vis = day_bin * binsize,
    reversal = ifelse(block != lead(block), "switch", "block")
  )

# creating a look-up table so the reversals can be marked 
rev_main_avg <- rev_learning_avg %>%
  filter(
    reversal == "switch",
    day %in% main_days
  ) %>%
  select(day, block, day_bin, day_bin_vis)

p1 <- rev_learning_avg %>%
  # filtering only the first three main days of the experiment:
  # one group had the experiment extended a further three days
  filter(day %in% main_days) %>%
  mutate(firstpoint = as.factor(ifelse(block == 1 & day == "Day 1", 1, 0))) %>% 
  ggplot(aes(day_bin_vis, y)) +
  geom_point(aes(color = firstpoint, fill = firstpoint), shape = 21) +
  scale_color_manual(values=c("0" = "black", "1" = "black")) + 
  #scale_color_manual(values=c("black", "black")) + 
  scale_fill_manual(values = c("0" = "black", "1" = "white")) + 
  geom_line() +
  geom_ribbon(aes(ymin = ymin, ymax = ymax), alpha = 0.3) +
  facet_grid(. ~ day) +
  scale_x_continuous(breaks = seq(50, 300, by = 50)) +
  ylim(0, 1.1) +
  geom_hline(yintercept = c(0.25, 0.5, 0.75, 1), linetype = "dotted") +
  geom_vline(aes(xintercept = day_bin_vis), rev_main_avg, linetype = "dashed") +
  # geom_vline(xintercept = seq(50, 300, by = 50), linetype = "dashed") +
  theme_classic() +
  labs(x = "Visits", y = "Proportion of total visits made \n to the rewarding option") + 
  theme(legend.position = "none")

p1
```

```{r, Calculating the proportion of wrongly unrewarded visits, message = FALSE, warning = FALSE, message = FALSE, echo=FALSE, results='hide'}
# adding the reversal block numbers and marking the reversals for the dataset with the unrewarded visits
rev_learning_all_unrew <- rev_learning_all_unrew %>% 
  # creating a column with the reversal block number, marking the reversals
  mutate(block = ifelse(MsgValue1 == "switch", 1, 0)) %>%
  group_by(day, Bat) %>%
  mutate(block = cumsum(block)) %>%
  ungroup() %>% 
  group_by(day, Bat, block) %>%
  # creating a column with the number of visits within each block
  mutate(block_vis = ifelse(MsgValue1 == "switch", 0, 1), 
         block_vis = cumsum(block_vis), 
         # creating a new column for visits in each block to be binned
         bin = "") %>%
  ungroup() %>%
  group_by(day, Bat, block) %>%
  # cutting the visits inside each block into bin of the size set earlier
  mutate(bin = as.numeric(cut(block_vis, breaks, include.lowest = TRUE)))

# adding a reward status to the table 
rev_learning_all_unrew <- rev_learning_all_unrew %>% 
  mutate(reward_status = ifelse(reinforce1value == 0 | Unrew == 1, 0, 1)) %>% 
  filter(!Bat %in% bats_beta, 
         day %in% main_days)

# what percentage of the bats' visits are wrongly unrewarded? 
mean_unrew <- rev_learning_all_unrew %>% 
  group_by(Bat, Day) %>% 
  filter(MsgValue1 != "switch") %>% 
  summarise(mean_unrew = mean(Unrew)) %>% 
  mutate(mean_unrew = mean_unrew *100)

overall_mean_unrew <- round(as.numeric(mean(mean_unrew$mean_unrew), digits = 2))
overall_sd_unrew <- round(as.numeric(sd(mean_unrew$mean_unrew)), digits = 2)

```

Furthermore, about `r overall_mean_unrew` % (SD = ±`r overall_sd_unrew`) of all visits made by the bats over all 3 Days were not rewarded, even though they were made to the rewarding flowers, due to the fact that they were made during the time the pump had been refilling. These visits were excluded from the following analysis. 

## b) Day and reversal block had a large effect on the number of perseverative visits 

As the bats experienced more reversals the largest change was seen in the number of perseverative visits, i.e., the visits made to the flower that was rewarding before the reversal before the first visit to the newly rewarding flower. The analysis showed that both day and block had a significant negative effect on this: as the bats experiences more reversals on more days the number of perseverative visits decreases. The interaction of day and block, however, was positive: the decrease in the number of perseverative visits was smaller as the bats experienced more experimental Days.  

```{r, message = FALSE, warning = FALSE, echo = FALSE, fig.cap = "Figure 3: Number of perseverative visits made by the individual bats after a reversal. Red lines are data from the individual bats, black lines are the mean number of visits averaged over bats", fig.width = 6, fig.height = 3}
#---------------------------------------------------
# Plotting the perseverative visits made by the bats
#---------------------------------------------------
pers_visits <- rev_learning_all %>% 
  select(-c(Group, Cage, Condition, Day, IdRFID, SystemMsg)) %>% 
  filter(block_vis != 0) %>% 
  group_by(Bat, day, block) %>% 
  mutate(first_rew = cumsum(reward_status)) %>% 
  filter(block > 1, 
         first_rew == 1, 
         reward_status == 1) %>% 
  ungroup() %>%
  group_by(day, block) %>% 
  mutate(mean_vis = mean(block_vis))

p2 <- pers_visits %>% 
  filter(day %in% main_days) %>% 
  ggplot(aes(block)) + 
  geom_line(aes(y = block_vis, group = Bat, color = "red"), alpha = 0.5) + 
  geom_line(aes(y = mean_vis), color = "black") + 
  facet_grid(.~day) + 
  ylim(0, 18) + 
  theme_bw() + 
  theme(legend.position = "none") + 
  ylab("# visits to the previous S+ before \n the first visit to a new S+") + 
  xlab("Reversal block")

p2
```

```{r, Modelling the perseverative visits and plotting the results, message = FALSE, warning = FALSE, message = FALSE, echo=FALSE, fig.cap = "Figure 4: Plot of slope coefficient values of the fixed effects", fig.width = 5, fig.height = 3}
#---------------
# Model fitting 
#---------------
# preparing the data table for the analysis of the perseverative visits 
analysis_pers <- rev_learning_all %>% 
  ungroup() %>% 
  select(Day, block, Bat, reward_status, block_vis, count_vis) %>%
  filter(block_vis != 0) %>% 
  group_by(Bat, Day, block) %>% 
  mutate(first_rew = cumsum(reward_status)) %>% 
  filter(block > 1, 
         first_rew == 1, 
         reward_status == 1)

# fitting a random slopes and random intercept model to the data, examining the effects of day, block and bin on the number of perseverative visits following a reversal; the response variable is taken to follow a negative-binomial distribution, which assumes that each Poisson count variable has its own rate parameter 

# m_pers <-
#   brm(data = analysis_pers, family = negbinomial,
#       block_vis ~ Day + block + Day:block + (1 + Day + block| Bat),
#       prior = c(prior(normal(0, 10), class = Intercept),
#                 prior(normal(0, 10), class = b),
#                 prior(cauchy(0, 1), class = sd)),
#       iter = 2000, warmup = 1000, chains = 4, cores = 4, thin = 3, 
#       control = list(adapt_delta = 0.999, 
#                      max_treedepth = 12),
#       seed = 12)
# 
# save(m_pers, file = "03_stats_rs_m4_negbinom.rda")
load("03_stats_rs_m4_negbinom.rda")
m_pers <- m3.1.1

rm(m3.1.1)

color_scheme_set("darkgray")

#model summary
t1 <- fixef(m_pers) %>% 
  as_tibble() %>% 
  mutate("Fixed effect" = c("Intercept", "Day", "Block", "Day-Block Interaction"), 
         Q2.5 = round(Q2.5, digits = 2), 
         Q97.5 = round(Q97.5, digits = 2), 
         # making a note of those rows where the slope coefficients do not overlap with 0
         bold = case_when(Q2.5 < 0 & Q97.5 < 0 ~ 1, 
                          Q2.5 > 0 & Q97.5 > 0 ~ 1), 
         row_num = 1:n())

# taking out the rows to be made bold as a vector
t1_bold <- t1 %>% filter(bold == 1) 
t1_bold <- as.vector(t1_bold$row_num)

t1 <- t1 %>% 
  mutate("95% Credibility intervals" = paste0("(", Q2.5, " , ", Q97.5, ")")) %>% 
  select("Fixed effect", "Estimate", "95% Credibility intervals")

# creating a plot of the slope coefficients 
p3 <- mcmc_intervals(m_pers, 
               pars = vars(2:4), 
               point_size = 1.75) + 
  geom_vline(xintercept = 0) + 
  theme_bw()

t1 <- kable(t1, 
      align = "l", 
      vline = " ", 
      #padding = 0, 
      caption = "Table 1: Results of the random regression model (brms), testing for the effects of day and block (fixed effects) on the number of perseverative visits (dependent variable)") %>%
  kable_styling(position = "center", full_width = F)

# marking the bold rows
row_spec(t1, t1_bold, bold = TRUE)

p3

```

Sampling from the posterior distribution and plotting the predictions showed a good fit of the model to the data, and showed the interaction between day and block clearly: on the first Day the slope was strongly negative; by the third Day the slopes were flat, and even slightly positive. 

```{r, message = FALSE, warning = FALSE, message = FALSE, echo=FALSE, fig.cap = "Figure 5: The posterior predictions of the model (blue line), compared with the empirical data from the bats (red line)", fig.width = 9.5, fig.height = 3}

# calculating the posterior predictions 
# selecting the required columns from the analysis dataframe 
nd_pers <- analysis_pers %>% 
  select(Bat, Day, block)

# calculating the posterior predictions 
post_fit <-
  fitted(m_pers,
         newdata = nd_pers) %>% 
  as_tibble() %>% 
  mutate(Bat = analysis_pers$Bat, 
         Day = analysis_pers$Day,
         block = analysis_pers$block, 
         count_vis = analysis_pers$block_vis)

# calculating the empirical equivalents of the posterior predictions 
comparison_pers <- analysis_pers %>% 
  group_by(Bat, Day, block) %>% 
  group_modify(~ mean_cl_boot(.x$block_vis, conf.int = 0.95))

# putting the calculated posterior values and the empirical values into the same table
comparison_pers <- left_join(analysis_pers, post_fit, by = c("Bat", "Day", "block"))

# plotting the posterior predicted values and empirical values together 
p3 <- comparison_pers %>% 
  ggplot(aes(block)) + 
  #geom_point(aes(y = y), color = "red", size = 0.2) +
  geom_line(aes(y = block_vis), color = "red") + 
  #geom_ribbon(aes(ymin = ymin, ymax = ymax), fill = "red", alpha = 0.3) + 
  geom_point(aes(y = Estimate), color = "blue", size = 0.2) + 
  geom_line(aes(y = Estimate), color = "blue") + 
  geom_ribbon(aes(ymin = Q2.5, ymax = Q97.5), fill = "blue", alpha = 0.3) +
  xlab("Block") + 
  ylab("Perseverative visits after a reversal before the \n first visit to the new S+ after a reversal") + 
  facet_grid(Day ~ Bat) + 
  theme_bw()

p3

```

**should there be a concluding sentence for this section?**

## c) Exploring the data-set further 

Further analyses were done to model as an outcome variable the proportion of visits to the S+ flower. IT is important to note that these were exploratory analyses done after the initial analysis of the perseverative visits was finished, to further illuminate the way the animals' behaviour changed as they experienced serial reversals. 

The first model we fit had Day, block and bin as fixed effects and random slopes and random intercepts for the individual bats. The second model was the same but expanded a little: as the first Day and first block of each day were by design different from the other Days and blocks respectively, predictor variables Day and block were also added as factors with two levels: the first Day and block; and the others. On comparing the two models using leave-one-out cross validation, the model that accounted for the first Day and block had a higher predictive accuracy than the one without (**Table 2**). 
The results of the model that accounts for the first Day and block are presented in **Figure 6**. Day, block and bin variables all had positive slope coefficients, but the interactions of Day and block, block and bin, and Day and bin all had negative slopes. Though the interactions effects were smaller than the main effects, the 95% credibility intervals of the former did not overlap with 0. Thus, the animals' choice for the S+ increases overall as they experience more and more Days and reversal blocks, and within each reveral block as it progresses, but this 'improvement' in their choice for the S+ decreases within each reversal block as it progresses, within each day as more reversals occur, and within each reversal block as the experimental Days progress. 
Furthermore, the variable 'block type', i.e., whether a block was the first reversal block of the Day or not had a significantly positive slope. The bats made more visits to the S+ before they had experienced any reversal at all. While the 'Day type' did not seem to affect the proportion of S+ visits, block type and Day type had an interaction effect: the first block of the first Day, before any reversals had ever been experienced even once, had the highest proportion of visits to the S+ compared to any other block on any other Day. 

```{r, Modelling the proportion of visits to the S+ and comparing two models, message = FALSE, warning = FALSE, message = FALSE, echo=FALSE}
#-----------------------------------------------------------------------
# Fitting the model without accounting for the first day and first block
#-----------------------------------------------------------------------

# creating the dataset for the analysis 
analysis_choices <- rev_learning_all %>% 
  ungroup() %>% 
  select(Day, block, bin, Bat, reward_status, block_vis, count_vis) %>% 
  filter(block_vis != 0)

# fitting the model 
# m_choices <-
#   brm(data = analysis_choices, family = binomial,
#       reward_status | trials(1) ~ Day + block + bin +
#         Day:block +
#         block:bin +
#         Day:bin +
#         (1 + Day + block + bin | Bat), # random slopes 
#       prior = c(prior(normal(0, 10), class = Intercept),
#                 prior(normal(0, 10), class = b),
#                 prior(cauchy(0, 1), class = sd)),
#       iter = 2000, warmup = 1000, chains = 4, cores = 5, thin = 3, 
#       control = list(adapt_delta = 0.9995, max_treedepth = 15),  
#       seed = 12)
# 
# # save the model 
# save(m_choices, file = "03_stats_rs_m1.1.rda")
#here is the model with the results, ready to be loaded. 
load("03_stats_rs_m1.1.rda")
m_choices <- m1.2.1
# removing the old model with the misleading name 
rm(m1.2.1)

#---------------------------------------------------------------
# Fitting the model accounting for the first day and first block
#---------------------------------------------------------------
analysis_choices2 <- analysis_choices %>% 
  mutate(day_type = as.factor(ifelse(Day == 1, 1, 0)), 
         block_type = as.factor(ifelse(block == 1, 1, 0)))
  
# m_choices2 <-
#   brm(data = analysis_choices2, family = binomial,
#       reward_status | trials(1) ~ 
#         Day + block + 
#         day_type + block_type + bin + 
#         Day:block + block:bin + Day:bin + 
#         day_type:block_type + block_type:bin + day_type:bin +
#         (1 + Day + block + day_type + block_type + bin | Bat), # random slopes 
#       prior = c(prior(normal(0, 10), class = Intercept),
#                 prior(normal(0, 10), class = b),
#                 prior(cauchy(0, 1), class = sd)),
#       # longer chains were needed for this more complex model to converge 
#       iter = 2500, warmup = 1200, chains = 4, cores = 5, thin = 3,
#       control = list(adapt_delta = 0.9995, max_treedepth = 15),  
#       seed = 12)

# save the model 
#save(m_choices2, file = "03_stats_rs_m6.rda")

#here is the model with the results, ready to be loaded. 
load("03_stats_rs_m6.rda")
m_choices2 <- m6
# removing the old model with the misleading name 
rm(m6)

m_choices <- add_criterion(m_choices, "loo")
m_choices2 <- add_criterion(m_choices2, "loo")

t2 <- loo_compare(m_choices, m_choices2, criterion = "loo") %>%
  as_tibble() %>% 
  mutate(Model = c("Day and block as both numeric and factor", "Day and block as only numeric")) %>% 
  select(c(9, 1:2)) %>% 
  rename("Difference in LOO estimates" = elpd_diff, 
         "Standard error" = se_diff)

t2 <- kable(t2, 
      align = "l", 
      vline = " ",
      #padding = 0, 
      caption = "Table 2: Comparison of the two models")  %>%
  kable_styling(position = "center", full_width = F)

column_spec(t2, 1, bold = TRUE)

```

```{r, Plotting the results of the model of the proportion of visits to the S+, message = FALSE, warning = FALSE, message = FALSE, echo=FALSE, fig.cap = "Figure 6: The effect of day, block, bin, day type and block type on the proportion of visits to the rewarding option. Plot of intercept and slope coefficient values of the fixed effects", fig.width = 8, fig.height = 3}

color_scheme_set("darkgray")

#model summary
t3 <- fixef(m_choices2) %>% 
  as_tibble() %>% 
  mutate("Fixed effect" = c("Intercept", "Day", "Block", "Day Type 1", "Block Type 1", "Bin", "Day-Block interaction", "Block-Bin interaction", "Day-Bin interaction", "Day Type 1-Block Type 1 interaction", 
                            "Block Type 1-Bin interaction", "Day Type 1-Bin interaction"), 
         Q2.5 = round(Q2.5, digits = 2), 
         Q97.5 = round(Q97.5, digits = 2), 
         # making a note of those rows where the slope coefficients do not overlap with 0
         bold = case_when(Q2.5 < 0 & Q97.5 < 0 ~ 1, 
                          Q2.5 > 0 & Q97.5 > 0 ~ 1), 
         row_num = 1:n()) 

# taking out the rows to be made bold as a vector
t3_bold <- t3 %>% filter(bold == 1) 
t3_bold <- as.vector(t3_bold$row_num)
         
t3 <- t3 %>% 
  mutate("95% Credibility intervals" = paste0("(", Q2.5, " , ", Q97.5, ")")) %>% 
  select("Fixed effect", "Estimate", "95% Credibility intervals")

# creating the plot of slope coefficients
p4 <- mcmc_intervals(m_choices2, 
               pars = vars(2:12), 
               point_size = 1.75) + 
  geom_vline(xintercept = 0) + 
  theme_bw()

# putting together the table of coefficients
t3 <- kable(t3, 
      align = "l", 
      vline = " ", 
      #padding = 0, 
      caption = "Table 3: Results of the random regression model (brms), testing for the effects of day, block, bin, day type and block type on the number of perseverative visits (dependent variable)")  %>%
  kable_styling(position = "center", full_width = F) 

# marking the bold rows 
row_spec(t3, t3_bold, bold = TRUE)

print(p4)
```

**Figure 7** shows the fit of the posterior predicted values of this model to the empirical data from the bats. While the model appears to be a good fit overall, it most notably seems to fail to capture the drop in the proportion of S+ visits in the very first bin following a reversal. It is this however that was analysed explicitly in the model fit to the number of perseverative visits; hence this model of the proportion of visits to the S+ was not further expanded to try capture the behaviour during the first bin of a block. 

```{r, Calculating and plotting the posterior predictions, message = FALSE, warning = FALSE, message = FALSE, echo=FALSE, fig.cap = "Figure 7: The posterior predictions of the model (blue line), compared with the empirical data from the bats (red line). Reversals are marked as the dotted line.", fig.width = 10, fig.height = 6}

# calculating the posterior predictions 
# selecting the required columns from the analysis dataframe 
nd_choices2 <- analysis_choices2 %>% 
  select(Bat, Day, block, bin, count_vis)

# calculating the posterior predictions 
post_fit <-
  predict(m_choices2) %>% 
  as_tibble() %>% 
  mutate(Bat = nd_choices2$Bat, 
         Day = nd_choices2$Day,
         block = nd_choices2$block, 
         bin = nd_choices2$bin, 
         count_vis = nd_choices2$count_vis)

# calculating the empirical equivalents of the posterior predictions 
comparison_choices2 <- analysis_choices2 %>% 
  group_by(Bat, Day, block, bin) %>% 
  group_modify(~ mean_cl_boot(.x$reward_status, conf.int = 0.95))

# look up table for splitting the data set 
split <- data.frame(
  Bat = c("Bat5", "Bat6", "Bat8", "Bat9", "Bat10", "Bat11", "Bat12", "Bat13", "Bat14", "Bat15", "Bat16", "Bat17", "Bat18", "Bat20"),
  row = as.factor(c(rep(1, 7), rep(2, 7)))) 

# putting the calculated posterior values and the empirical values into the same table
comparison_choices2 <- left_join(comparison_choices2, post_fit, by = c("Bat", "Day", "block", "bin"))
comparison_choices2 <- left_join(comparison_choices2, split, by = "Bat")

# plotting the posterior predicted values and empirical values together 
p5 <- comparison_choices2 %>% 
  filter(row == 1) %>% 
  ggplot(aes(count_vis)) + 
  #geom_point(aes(y = y), color = "red", size = 0.2) +
  geom_line(aes(y = y), color = "red") + 
  geom_ribbon(aes(ymin = ymin, ymax = ymax), fill = "red", alpha = 0.3) + 
  #geom_point(aes(y = Estimate), color = "blue", size = 0.2) + 
  geom_line(aes(y = Estimate), color = "blue", alpha = 0.5) + 
  #geom_ribbon(aes(ymin = Q2.5, ymax = Q97.5), fill = "blue", alpha = 0.3) + 
  geom_vline(xintercept = c(50, 100, 150, 200, 250), linetype = "dashed", size = 0.2) + 
  xlab("Visit count") + 
  ylab("Proportion of visits to the S+") + 
  scale_y_continuous(breaks = c(0, 0.5, 1)) + 
  facet_grid(Day ~ Bat) + 
  theme_classic()

p6 <- comparison_choices2 %>% 
  filter(row == 2) %>% 
  ggplot(aes(count_vis)) + 
  #geom_point(aes(y = y), color = "red", size = 0.2) +
  geom_line(aes(y = y), color = "red") + 
  geom_ribbon(aes(ymin = ymin, ymax = ymax), fill = "red", alpha = 0.3) + 
  #geom_point(aes(y = Estimate), color = "blue", size = 0.2) + 
  geom_line(aes(y = Estimate), color = "blue", alpha = 0.5) + 
  #geom_ribbon(aes(ymin = Q2.5, ymax = Q97.5), fill = "blue", alpha = 0.3) + 
  geom_vline(xintercept = c(50, 100, 150, 200, 250), linetype = "dashed", size = 0.2) + 
  xlab("Visit count") + 
  ylab("Proportion of visits to the S+") + 
  scale_y_continuous(breaks = c(0, 0.5, 1)) + 
  facet_grid(Day ~ Bat) + 
  theme_classic()

ggarrange(p5, p6, nrow = 2, ncol = 1)

```

**Should there be an overall conclusion?** 

# Supplementary Information 
## The weights of the bats at the start and finish of the experiment 
The bats' weights at the start and finish of the experiment are in **Supplementary Table 1**.  
```{r, results='asis'}

st1 <- data.frame(
  Individual = c("Bat5", "Bat6", "Bat8", "Bat9", "Bat10", "Bat11", "Bat12", "Bat13", "Bat14", "Bat15", "Bat16", "Bat17", "Bat18", "Bat20"),
  Sex = rep(c("Female", "Male"), 1, each = 7),
  `Flight cage` = c(rep(2, 3), rep(c(1, 2), 1, each = 4), rep(1, 3)),
  # how do you insert spaces into column names?
  `Weight on capture [g]` = c(9, 8.5, 8.5, 8.5, 8.5, 9, 10, 8.5, 9, 9.5, 10, 10, 10.5, 9.5),
  `Weight on release [g]` = c(8.5, 8.5, 8.5, 8, 8, 8.5, 9, 8, 8, 8, 9.5, 8, 8.5, 8.5),
  check.names = FALSE
)

kable(st1, align = "c", 
      vline = " ", 
      #padding = 0
      caption = "Supplementary Table 1: Weights of the 14 bats that completed the experiment)"
      ) %>%
  kable_styling("striped", position = "center", full_width = F)

```

## Individual bats' choice behaviour 
Each individual visit made by each bat is plotted in **Figure S1**, including the wrongly unrewarded visits so their distribution can be seen clearly. 
```{r, Plotting all the individual choices, fig.cap= "Figure S1: All individual choices of the bats for the rewarding and non-rewarding options. The black line is the choice for either the S+ or S-, marked as 1 or 0 on the Y-axis respectively. The red lines indicate when a reversal took place and the purple areas mark the wrongly unrewarded visits", fig.width = 12, fig.height = 7}

# creating a look-up table so the reversals can be marked in the plots for the main experimental bats
unrew_revs <- rev_learning_all_unrew %>%
  filter(
    MsgValue1 == "switch", 
    block != 1
  ) %>%
  select(day, Bat, count_vis, block, bin, MsgValue1)

unrew_vis <- rev_learning_all_unrew %>% 
  filter(
    Unrew == 1
  ) %>%
  select(day, Bat, count_vis, block, bin, MsgValue1)

s1 <- rev_learning_all_unrew %>%
  filter(day %in% main_days) %>%
  ggplot(aes(count_vis, reward_status)) +
  geom_line() +
  facet_grid(Bat ~ day) +
  geom_vline(aes(xintercept = count_vis), unrew_revs, colour = "red") +
  geom_vline(aes(xintercept = count_vis), unrew_vis, colour = "purple") +
  scale_x_continuous(breaks = seq(0, 350, by = 25)) + 
  scale_y_continuous(breaks = c(0, 1)) + 
  ylab("Choice for the more profitable option") +
  xlab("Visits") +
  theme_classic()

s1
```

## Average choice behaviour and the number of bats that completed each block 

Not all the bats finished all 6 reversal blocks every Day. The sample size of each reversal block along with the average proportion of S+ visits is given in **Figure S2**. 

```{r, Plotting the average behaviour with the sample sizes, fig.cap = "Figure S2: Average preferences of the bats and the sample size of each block. The first block before the bats experienced any reversals at all is marked with white points, the rest with black points. Shaded areas are 95% confidence intervals", fig.width = 9, fig.height = 3}

# calculating the sample size in each block 
bat_labels <- rev_learning_avg %>% 
  select(day, block, n_bats) %>%
  distinct() %>% 
  group_by(day, block) %>% 
  mutate(day_bin_vis = ifelse(block == 1, 25, 50)) %>%
  ungroup() %>% 
  group_by(day) %>% 
  mutate(day_bin_vis = cumsum(day_bin_vis)) %>% 
  filter(day %in% main_days)

s2 <- rev_learning_avg %>%
  # filtering only the first three main days of the experiment:
  # one group had the experiment extended a further three days
  filter(day %in% main_days) %>%
  mutate(firstpoint = as.factor(ifelse(block == 1 & day == "Day 1", 1, 0))) %>% 
  ggplot(aes(day_bin_vis, y)) +
  geom_point(aes(color = firstpoint, fill = firstpoint), shape = 21) +
  scale_color_manual(values=c("0" = "black", "1" = "black")) + 
  scale_fill_manual(values = c("0" = "black", "1" = "white")) + 
  geom_line() +
  geom_ribbon(aes(ymin = ymin, ymax = ymax), alpha = 0.3) +
  facet_grid(. ~ day) +
  scale_x_continuous(breaks = seq(50, 300, by = 50)) +
  ylim(0, 1.1) +
  geom_hline(yintercept = c(0.25, 0.5, 0.75, 1), linetype = "dotted") +
  geom_vline(aes(xintercept = day_bin_vis), rev_main_avg, linetype = "dashed") +
  theme_classic() +
  geom_text( data = bat_labels, 
             aes(x = day_bin_vis, y = 1.05, label = n_bats, group = n_bats)) + 
  labs(x = "Visits", y = "Proportion of total visits made to the rewarding option") + 
  theme(legend.position = "none")

s2
```

## Inter-visit intervals: DO WE NEED THIS?
**Figure S3** shows the distribution of inter-visit intervals. 

```{r, Calculating and plotting the inter-visit intervals, fig.cap= "Figure S3: Distribution of inter-visit intervals [s]", fig.height = 2.5}
#-----------------------
# Inter-visit intervals
#-----------------------
# calculating the inter-visit intervals of all the bats 

rev_learning_ivi <- rev_learning_all %>%
  group_by(Day, Bat) %>%
  mutate(interval = as.integer(difftime(lead(DateTime), DateTime, units = "secs")))

s3 <- rev_learning_ivi %>%
  filter(day %in% main_days) %>%
  ggplot(aes(interval, group = Bat)) +
  geom_density(fill = "black", color = "transparent", alpha = 0.08) +
  facet_grid(. ~ Day) +
  scale_x_log10() +
  theme_bw() +
  xlab("intervisit intervals [s]") +
  scale_fill_viridis_d()

s3
```